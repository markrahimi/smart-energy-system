
<!-- 
  This the root component of our Vue app, it displays the list of notes, each note is rendered by an instance
  of the vue Note component. Latter, we will also add components for the note creation form, the filter list,
  and the message pop up.

  All the code in this file (called a Vue Single File Component), will be translated by the Vue toolchain into
  pure javascript and CSS, sent to the browser. Under the hood, it works thanks to a bundler tool, here it's Vite,
  but it could also be Webpack.

  See: https://vuejs.org/guide/scaling-up/sfc.html
-->

<!-- 
  Here we define the template of our component, that reflects the HTML that will be generated by the Vue engine
-->
<template>
  <error-overlay />
  <NoteFilter @onFilterChange="setFilter"></NoteFilter>
  <div class="notes-container">
    <!-- 
      with the directive `v-for`, we loop over the items of the array notesList, and for each item we create
      an instance of Note component. We need to provide a unique id to each instance of the loop (used by Vue 
      for state tracking), and we pass the corresponding note object to the Note component using its prop "note"

      See: https://vuejs.org/guide/essentials/list.html
    -->
    <Note
      v-for="note in filteredNotes"
      :key="note.id"
      :note="note"
      @onNoteDeleted="removeNote"
    ></Note>

    <!--
      We listen to the custom event defined by the component NoteCreationForm. This event will call the provided
      method, with the new note object as first argument.

      See: 
        - https://vuejs.org/guide/essentials/event-handling
        - https://vuejs.org/guide/components/events
    -->
    <NoteCreationForm @onNoteCreated="addNewNote"></NoteCreationForm>
  </div>
</template>


<!-- 
  Here we write our javascript logic, that will be executed within the Vue framework (so we must follow its convention)

  I choose to use the "Options" API of VueJS, over the "Composition" API because IMO it leads to clearer code.

  See: https://vuejs.org/guide/extras/composition-api-faq
-->
<script>
  import {HOST} from './config.js'
  import Note from './Note.vue'
  import NoteCreationForm from './NoteCreationForm.vue'
  import ErrorOverlay from './ErrorOverlay.vue'
  import NoteFilter from './NoteFilter.vue'
  import { sendMessage } from './services/errorService.js'
  import { connect, onMessage, removeObserver } from './services/websocketService.js'

  export default {
    components: {
      /*
       * Here we register all the children components that will be used in our template. It's the JS object exported
       * by the `Component.vue` file (this is done by the bundler)
       *
       * See: https://vuejs.org/guide/components/registration.html
      */
      Note,  // This is a shortcut syntax for `Note: Note`, when the key and the value are the same in a JS object.
      NoteCreationForm,
      ErrorOverlay,
      NoteFilter
    },
    data() {
      return {
        /*
         * Here we put all the variables we want to use in our template, and initialize them
         * with a default value.
         *
         * In the template, we can access these variables directly with their names, like `<div>{{notesList[0].name}}</div>
         *
         * In the other methods/functions of our Vue component, we can access them as property of `this`, e.g `this.notesList`
         *
         * See: https://vuejs.org/guide/essentials/reactivity-fundamentals.html
         */
        notesList: [], // array of note objects, that will be populated after requesting notes from the server
        selectedFilter: 'all' // current filter selection
      }
    },
    computed: {
      filteredNotes() {
        if (this.selectedFilter === 'all') {
          return this.notesList
        }
        return this.notesList.filter(note => note.status === this.selectedFilter)
      }
    },
    methods: {
      /*
       * Here we put methods, that is functions that could be called from the template. If the output
       * of such methods were dependent of the state of variables declared in `data`, it would be better
       * to put them under `computed`
       */
      addNewNote(newNote) {
        if (!this.notesList.find(n => n.id === newNote.id)) {
          this.notesList.push(newNote)
        }
      },
      removeNote(noteId) {
        this.notesList = this.notesList.filter(n => n.id !== noteId)
      },
      setFilter(filter) {
        this.selectedFilter = filter
      },
      handleWebSocketMessage(data) {
        if (data.event === 'noteCreated') {
          this.addNewNote(data.note)
        } else if (data.event === 'noteDeleted') {
          this.removeNote(data.note.id)
        } else if (data.event === 'noteUpdated') {
          const index = this.notesList.findIndex(n => n.id === data.note.id)
          if (index !== -1) {
            this.notesList[index] = data.note
          }
        }
      }
    },
    mounted() {
      /*
       * This is a lifecycle hook, this function will run automatically when this component  is mounted in our Vue app.
       * This is the good place to make our initial server request, because we want it to run at the start of our application,
       * but not too soon because we need the component to be ready in order to update its content with the result of
       * the request.
       *
       * See: https://vuejs.org/guide/essentials/lifecycle.html for more info on the lifecycle hooks
       */
      fetch(`${HOST}/notes`)
        .then(res => {
          if (!res.ok) throw new Error('Failed to fetch notes')
          return res.json()
        })
        .then(res => this.notesList = res)
        .catch(err => sendMessage(err.message));

      connect();
      this.wsObserver = (data) => this.handleWebSocketMessage(data);
      onMessage(this.wsObserver);
    },
    beforeUnmount() {
      removeObserver(this.wsObserver);
    }
  }
</script>


<!--
  Here we write our stylesheet rules that will apply to the HTML generated for this Vue component. The Vue engine
  will "scope" this rules, so they can apply only to your component and not other parts of the web page, even if your use 
  class names that exist elsewhere (you can inspect in your browser developper tools how it's done)

  Also, the Vue framework handles for us the transpilation of other stylesheet languages into pure CSS. Here we use SCSS

  See: https://vuejs.org/api/sfc-css-features.html
-->
<style lang="scss" scoped>
@use 'assets/stylesheets/mediaQueryScreens.scss';

$gutter-size: 15px;

.notes-container {
  display: flex;
  flex-wrap: wrap;
  gap: $gutter-size;

  margin-right: auto;
  margin-left: auto;

  border: 1px solid gray;
  border-radius: 10px;

  padding: $gutter-size;
}

@include mediaQueryScreens.small { 
  .notes-container {
    width: 90vw;
  }

}

@include mediaQueryScreens.medium { 
  .notes-container {
    width: 80vw;
  }

}

@include mediaQueryScreens.large { 
  .notes-container {
    width: 1024px;
  }
}
</style>
